// Code generated by gs. DO NOT EDIT
package http

import (
	"{{ .Import }}/gen/endpoint"
	"context"
    "encoding/json"
    "encoding/xml"
    goHttp "net/http"

    "github.com/gorilla/schema"

    goKitHttp "github.com/go-kit/kit/transport/http"
    "github.com/gorilla/mux"
)

type Method string

const (
	GET     Method = goHttp.MethodGet
	PUT            = goHttp.MethodPut
	POST           = goHttp.MethodPost
	HEAD           = goHttp.MethodHead
	PATCH          = goHttp.MethodPatch
	DELETE         = goHttp.MethodDelete
	OPTIONS        = goHttp.MethodOptions
	TRACE          = goHttp.MethodTrace
	CONNECT        = goHttp.MethodConnect
)

var decoder = schema.NewDecoder()

type MethodRoute struct {
	Name   string
	Methods []Method
	Route  string
}

type HTTP interface {
	MethodRoutes() []MethodRoute
	Handler() goHttp.Handler
}
type Transport interface {
	Address() string
	Router() *mux.Router
}

type httpTransport struct {
    options_ options
    {{ range .Endpoints}}{{if .HttpTransport}}{{ lowerFirst( .Name ) }} HTTP{{end}}
    {{ end }}}

func setDefaultOptions(opts *options) {
	if opts.address == "" {
		opts.address = "{{ .Config.Http.Url }}:{{ .Config.Http.Port }}"
	}
	if opts.router == nil {
		opts.router = mux.NewRouter()
	}
	if opts.errorEncoder == nil {
		opts.errorEncoder = goKitHttp.DefaultErrorEncoder
	}
	if opts.jsonEncoder == nil {
		opts.jsonEncoder = goKitHttp.EncodeJSONResponse
	}
	if opts.jsonDecoder == nil {
		opts.jsonDecoder = DecodeJsonRequest
	}
	if opts.xmlEncoder == nil {
		opts.xmlEncoder = EncodeXMLResponse
	}
	if opts.xmlDecoder == nil {
		opts.xmlDecoder = DecodeXmlRequest
	}
	if opts.formDecoder == nil {
		opts.formDecoder = DecodeFormRequest
	}
}

func MakeHttpTransport(endpoints endpoint.Endpoints, opts ...Option) Transport {
    httpOptions := &options{}
        for _, o := range opts {
            o(httpOptions)
        }
	setDefaultOptions(httpOptions)
	return &httpTransport{
        options_: *httpOptions,
        {{ range .Endpoints }}{{if .HttpTransport}}{{ lowerFirst( .Name ) }}: make{{ .Name }}HttpTransport(endpoints.{{ .Name }}(), *httpOptions, httpOptions.{{ lowerFirst( .Name ) }}Options...),{{ end }}
    {{ end }}}
}

func (t httpTransport) Address() string {
	return t.options_.address
}

func (t httpTransport) Router() *mux.Router {
	all := []HTTP{
		{{ range .Endpoints }}{{if .HttpTransport}}t.{{ lowerFirst( .Name ) }},{{end}}
	{{ end }}}

	for _, method := range all {
        for _, route := range method.MethodRoutes() {
            var methods []string
            for _, method := range route.Methods {
                methods = append(methods, string(method))
            }
            t.options_.router.Methods(methods...).Path(route.Route).Handler(method.Handler())
        }
    }
	if t.options_.notFoundHandler != nil {
		t.options_.router.NotFoundHandler = t.options_.notFoundHandler
	}
    return t.options_.router
}

func EncodeXMLResponse(_ context.Context, w goHttp.ResponseWriter, response interface{}) error {
	w.Header().Set("Content-Type", "application/xml; charset=utf-8")
	if headerer, ok := response.(goKitHttp.Headerer); ok {
		for k, values := range headerer.Headers() {
			for _, v := range values {
				w.Header().Add(k, v)
			}
		}
	}
	code := goHttp.StatusOK
	if sc, ok := response.(goKitHttp.StatusCoder); ok {
		code = sc.StatusCode()
	}
	w.WriteHeader(code)
	if code == goHttp.StatusNoContent {
		return nil
	}
	return xml.NewEncoder(w).Encode(response)
}

func DecodeJsonRequest(r *goHttp.Request, strc interface{}) error {
	if r.Body == goHttp.NoBody {
		return nil
	}
	return json.NewDecoder(r.Body).Decode(strc)
}

func DecodeXmlRequest(r *goHttp.Request, strc interface{}) error {
	if r.Body == goHttp.NoBody {
		return nil
	}
	return xml.NewDecoder(r.Body).Decode(strc)
}

func DecodeFormRequest(r *goHttp.Request, strc interface{}) error {
	err := r.ParseForm()
	if err != nil {
		return err
	}
	return decoder.Decode(strc, r.PostForm)
}
