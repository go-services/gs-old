// Code generated by gs. DO NOT EDIT
package gen
import (
    service "{{ .Import }}"
    "{{ .Import }}/gen/endpoint"
    genHttpTransport "{{ .Import }}/gen/transport/http"{{if .GRPCTransport}}
    genGrpcTransport "{{ .Import }}/gen/transport/grpc"{{end}}
    "fmt"
    "net"
    "net/http"
    "os"
    "os/signal"
    "runtime/debug"
    "syscall"

    "github.com/go-kit/kit/log"
    "github.com/go-kit/kit/log/level"
    "github.com/oklog/run"
    "google.golang.org/grpc"
)

type serviceTransport struct {
    http genHttpTransport.Transport{{if .GRPCTransport}}
    grpc genGrpcTransport.Transport{{end}}
}

type GeneratedService interface {
	Run()
}

type generatedService struct {
	options    options
	transports *serviceTransport
}

func New(svc service.Service, options ...Option) GeneratedService {
	genSvc := generatedService{}
	for _, option := range options {
		option(&genSvc.options)
	}
	if genSvc.options.serviceLogger == nil {
		genSvc.options.serviceLogger = log.NewLogfmtLogger(os.Stdout)
	}

	if genSvc.options.serviceMode == none {
		genSvc.options.serviceMode = PROD
	}

	if genSvc.options.debugAddress == "" {
		genSvc.options.debugAddress = "{{ .Config.Debug.Url }}:{{ .Config.Debug.Port }}"
	}

	for _, m := range genSvc.options.serviceMiddleware {
		svc = m(svc)
	}

	endpoints := endpoint.MakeEndpoints(svc, genSvc.options.endpointOptions...)

	httpTransport := genHttpTransport.MakeHttpTransport(endpoints, genSvc.options.httpOptions...)
    {{if .GRPCTransport}}
	grpcTransport := genGrpcTransport.MakeGRPCTransport(endpoints, genSvc.options.grpcOptions...)
    {{ end }}
	genSvc.transports = &serviceTransport{
		http: httpTransport, {{if .GRPCTransport}}
		grpc: grpcTransport, {{ end }}
	}
	return genSvc
}

func (service generatedService) Run() {
	var g run.Group
	{
		if service.options.serviceMode == DEBUG {
			// The debug listener mounts the http.DefaultServeMux, and serves up
			// stuff like the Prometheus metrics route, the Go debug and profiling
			// routes, and so on.
			var debugAddr = service.options.debugAddress
			debugListener, err := net.Listen("tcp", debugAddr)
			if err != nil {
				_ = service.options.serviceLogger.Log("transport", "debug/HTTP", "during", "Listen", "err", err)
				os.Exit(1)
			}
			g.Add(func() error {
				_ = service.options.serviceLogger.Log("transport", "debug/HTTP", "addr", debugAddr)
				return http.Serve(debugListener, http.DefaultServeMux)
			}, func(error) {
				_ = debugListener.Close()
			})
		}
	}
	{
		err := setupTransports(service, &g)
		if err != nil {
			_ = service.options.serviceLogger.Log("transport", "HTTP", "during", "Listen", "err", err)
			os.Exit(1)
		}
	}
	{
		var (
			cancelInterrupt = make(chan struct{})
			c               = make(chan os.Signal, 2)
		)
		g.Add(func() error {
			signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)
			select {
			case sig := <-c:
				return fmt.Errorf("received signal %s", sig)
			case <-cancelInterrupt:
				return nil
			}
		}, func(error) {
			close(cancelInterrupt)
		})
		defer close(c)
	}
	// run the group
	if err := level.Error(service.options.serviceLogger).Log("exit", g.Run()); err != nil {
		println("error while writing log, this should never happen...")
		debug.PrintStack()
	}
}
func setupTransports(service generatedService, g *run.Group) error {
	listener, err := net.Listen("tcp", service.transports.http.Address())
	if err != nil {
		return err
	}
	g.Add(func() error {
		_ = service.options.serviceLogger.Log("transport", "HTTP", "addr", service.transports.http.Address())
		return http.Serve(listener, service.transports.http.Router())
	}, func(error) {
		err := listener.Close()
		if err != nil {
			fmt.Printf("There where blocked Accept operations when closing listener : %v", err)
		}
	})
    {{if .GRPCTransport}}
	grpcListener, err := net.Listen("tcp", service.transports.grpc.Address())
	if err != nil {
		_ = service.options.serviceLogger.Log("transport", "gRPC", "during", "Listen", "err", err)
		os.Exit(1)
	}
	g.Add(func() error {
		_ = service.options.serviceLogger.Log("transport", "gRPC", "addr", service.transports.grpc.Address())
		// we add the Go Kit gRPC Interceptor to our gRPC service as it is used by
		// the here demonstrated zipkin tracing middleware.
		baseServer := grpc.NewServer()
		genGrpcTransport.RegisterServiceServer(baseServer, service.transports.grpc.Server())
		return baseServer.Serve(grpcListener)
	}, func(error) {
		_ = grpcListener.Close()
	})
    {{ end }}
	return nil
}
